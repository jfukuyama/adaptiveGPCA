---
title: "Adaptive gPCA Vignette"
author: "Julia Fukuyama"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Adaptive gPCA Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Adaptive gPCA Vignette

```{r, echo = FALSE}
library(knitr)
opts_chunk$set(fig.width = 8, fig.height = 4)
```
Here we will describe how to use the adaptiveGPCA package. The general
idea behind adaptive gPCA is to obtain a low-dimensional
representation of the data, like with PCA, which incorporates side
information about the relationships between the variables. The output
is similar to a PCA biplot, but the variable loadings are regularized
so that similar variables are encouraged to have similar loadings on
the principal axes.

We'll demonstrate how to use it with a dataset
which is included in the package which describes the results of a
microbiome experiment. For this data, variables are the species or
OTUs whose abundances are measured, and the similarity between the
species is defined by their phylogeny.

The data included is a list
with four components: `otutab` is a matrix containing filtered
variance-stabilized OTU proportions from each sample, `Q` is an inner
product or similarity matrix for this data which comes from the phylogenetic tree
describing the relationships between the OTUs, `sampledata` gives some
characteristics of the samples, and `variabledata` gives some
characteristics of the OTUs. We first load in the package and the
data.
```{r}
library(adaptiveGPCA)
library(ggplot2)
library(phyloseq)
data(abt_data)
```

Then we can look at adaptive gPCA on this same data set using the
adaptivegPCA command. The adaptive gPCA function requires a data
matrix (in this case `abt_data$otutab`) and a measure of similarity
between the variables. This can be either the similarity matrix `Q` or
its eigendecomposition. In this case we pass in the eigendecomposition
because the computation takes a little bit of time and we don't want
to have to re-compute it later.
```{r}
Qeig = eigen(abt_data$Q, symmetric = TRUE)
out.agpca = adaptivegPCA(abt_data$otutab, Qeig, k = 2)
```

Alternately, if we want to use the shiny interface to choose how much
of the tree constraints to use, we can first use the `gpcaFullFamily`
function to create a full set of ordinations and then use the
`visualizeFullFamily` function to visualize the biplots at each value of
the constraint.

The `visualizeFullFamily` function is a shiny "gadget",
and so will open a browser window where you can visualize the data set
with various constraints. Clicking "done" in this window will give as
output an object of the same format as that given by the `adaptivegPCA`
function, the difference being that the value of r was chosen manually
instead of automatically. (The code below is only included as an
example and not evaluated in the vignette.) If you run this yourself
it will take little bit of time --- on my laptop it takes about a
minute and a half for the first line to run. 
```{r, eval = FALSE}
out.ff = gpcaFullFamily(abt_data$otutab, Qeig, k = 2)
out.agpca = visualizeFullFamily(out.ff,
                    sample_data = abt_data$sampledata,
                    sample_mapping = aes(x = Axis1, y = Axis2, color = condition),
                    var_data = abt_data$variabledata,
                    var_mapping = aes(x = Axis1, y = Axis2, color = Phylum))
```

In either case, we can plot the results. As desired, we get a nice
biplot representation where similar species are located in similar
positions. The sample scores on the principal axes are located in
`out.agpca$U` and the loadings of the variables on the principal axes
are located in `out.agpca$QV`. 
```{r}
ggplot(data.frame(out.agpca$U, abt_data$sampledata)) +
    geom_point(aes(x = Axis1, y = Axis2, color = type, shape = ind))
ggplot(data.frame(out.agpca$QV, abt_data$variabledata)) +
    geom_point(aes(x = Axis1, y = Axis2, color = Phylum))
out.agpca$r
```

The example above showed how to use adaptive gPCA with a general data
matrix and inner product matrix. This package also has a function that
allows you to take a phyloseq object and extract the data matrix (`X`),
the row inner product matrix based on the phylogeny (`Q`), and the
column inner product matrix giving the sample weights (`weights`) that
should be passed to the `adaptivegPCA` function, as illustrated
below. In this case, the phyloseq object already has
variance-stabilized OTU abundances, but in general it is important to
make some sort of variance-stabilizing transformation of the
abundances before performing adaptive gPCA.

The next block of code shows how to process a phyloseq object (`abt`)
for input to the `adaptivegPCA` function and plots the results. 
```{r}
data(abt)
pp = processPhyloseq(abt)
out.agpca = adaptivegPCA(X = pp$X, Q = pp$Q, weights = pp$weights, k = 2)
ggplot(data.frame(out.agpca$U, sample_data(abt))) +
    geom_point(aes(x = time, y = Axis2, color = condition)) + facet_wrap(~ ind)
ggplot(data.frame(out.agpca$QV, tax_table(abt))) +
    geom_point(aes(x = Axis1, y = Axis2, color = Phylum))
```

Finally, note that the `processPhyloseq` function also has an argument `ca`
(for correspondence analysis). This should be used with phyloseq
objects containing raw counts, and it will process a phyloseq object
so as to do an adaptive gPCA version of correspondence analysis (this
entails transforming counts to relative abunadnces, computing sample
weights based on the overall counts for the samples, and finally doing
a weighted centering of the relative abundances).
